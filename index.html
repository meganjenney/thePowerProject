<style>
  @import url('https://fonts.googleapis.com/css2?family=PT+Sans&display=swap');

  html {
      font-family: 'PT Sans', sans-serif;
  }

  .buttons {
      cursor: pointer;
      opacity: 0;
      transition-property: opacity;
      font-size: 10pt;
  }

  .label {
      cursor: pointer;
  }

  .label:hover + .buttons, .buttons:hover {
      opacity: 1;
  }

  .buttons a {
      margin: 0.1em;
      padding: 0.1em;
      opacity: 0.5;
      transition-property: opacity;
      background-color: #dddddd;
      border: solid;
      border-width: 1px;
      border-color: #aaaaaa;
  }

  .buttons a:hover {
      opacity: 1;
  }

  /* draw tree structure */
  /* https://gist.github.com/dylancwood/7368914 */
  ul#tree_root, ul#tree_root ul {
      list-style: none;
      margin: 0;
      padding: 0;
  }
  ul#tree_root ul {
      margin-left: 10px;
  }
  ul#tree_root li {
      margin: 0;
      padding: 0 7px;
      line-height: 20px;
      border-left:2px solid rgb(100,100,100);

  }
  ul#tree_root li:last-child {
      border-left:none;
  }
  ul#tree_root li:before {
      position:relative;
      top:-0.3em;
      height:1em;
      width:12px;
      color:white;
      border-bottom:2px solid rgb(100,100,100);
      content:"";
      display:inline-block;
      left:-7px;
  }
  ul#tree_root li:last-child:before {
      border-left:2px solid rgb(100,100,100);
  }

  .shutdown,
  .off {
      text-decoration: line-through;
      background-color: #d1585e;
  }

  .on {
      background-color: #9ae080;
  }
</style>
<div style="display: flex;">
<ul id="tree_root">
</ul>
<canvas id="canvas" width=200 height=200>
</canvas>
</div>

<script>

const approved_colors = [
    "#C62828",
    "#AD1457",
    "#6A1B9A",
    "#4527A0",
    "#283593",
    "#1565C0",
    "#0277BD",
    "#00838F",
    "#00695C",
    "#2E7D32",
    "#558B2F",
    "#9E9D24",
    "#F9A825",
    "#EF6C00",
    "#D84315",
    "#4E342E",
    "#424242"
];

const history_length = 10;
const tree_root = document.getElementById("tree_root");

const c = document.getElementById("canvas");
const ctx = c.getContext("2d");
let graph_history = {};
let t = 0;
console.log(tree_root);

setInterval(function() {
    request_info(function(data) {
	tree_root.innerHTML = "";
	populate_tree(tree_root, data);
	update_graph_history(data, t);
	t += 1;
	draw_history();
    });
}, 1000);

// note: this is a horrible hashing function, but
// it doesn't need to be good
function hash(string) {
    n = 0;
    for(let i = 0; i < string.length; ++i) {
	n += string.charCodeAt(i);
    }
    return n;
}

function name_to_color(name) {
    let n = hash(name);
    return approved_colors[n % approved_colors.length];
}

function max_power_in_history() {
    let max = 0;
    for(const node in graph_history) {
	let history = graph_history[node];
	for(const history_elem of history) {
	    if(history_elem[1] > max) max = history_elem[1];
	}
    }

    return max;
}

function max(a, b) {
    return a > b ? a : b;
}

function draw_history() {
    const padding = 5;

    const max_power = max_power_in_history();
    const v_scale = (c.height - padding * 2) / max(max_power, 1);
    const h_scale = (c.width  - padding * 2) / history_length;

    ctx.clearRect(0, 0, c.width, c.height);
    for(const node in graph_history) {
	let history = graph_history[node];
	ctx.beginPath();

	ctx.strokeStyle = name_to_color(node);
	ctx.moveTo(0, 0);
	ctx.lineWidth = 2.0;
	for(let i = 0; i < history.length; ++i) {
	    let offset = t - history[i][0];
	    let power = history[i][1];

	    const x = c.width - (offset * h_scale + padding);
	    const y = c.height - (power * v_scale + padding);
	    if(i == 0) {
		ctx.moveTo(x, y);
	    } else {
		ctx.lineTo(x, y);
	    }
	}

	ctx.stroke();
    }
}

function remove_from_history(name) {
    delete graph_history[name];
    draw_history();
}

function update_graph_history(data, t) {
    let name = data.name ? data.name : "house";
    let power = data.current_usage.toString();
    let status = data.status ? data.status : "";

    if(graph_history[name]) {
	// push the new datapoint to this node's history
	graph_history[name].push([t, status == "off" ? 0 : power]);
	if(graph_history[name].length > history_length) {
	    graph_history[name].shift();
	}
    } else {
	// node is new
	graph_history[name] = [];
    }

    if(!data.children) return;

    // recurse on the node's children
    for(const child of data.children) {
	update_graph_history(child, t);
    }
}

function request_action(url) {
    let xmlHttp = new XMLHttpRequest();
    xmlHttp.open("POST", url, true);
    xmlHttp.send(null);
}

function handle_click(node_name, button_name) {
    if(button_name == "new appliance") {
	let parent = node_name;
	let name = prompt("appliance name");
	let power = prompt("appliance power");
	if(!/\d+\.\d+/.test(power)) {
	    alert("Invalid float literal: " + power)
	    return;
	}

	let clock = "1";
	request_action(`/new_appliance?parent=${parent}&name=${name}&power=${power}&clock=${clock}`);
    } else if(button_name == "new breaker") {
	let name = prompt("breaker name");
	let power = prompt("breaker maximum power");
	if(!/\d+\.\d+/.test(power)) {
	    alert("Invalid float literal: " + power)
	    return;
	}

	request_action(`/new_breaker?name=${name}&power=${power}`);
    } else if(button_name == "delete") {
	let name = node_name;
	request_action(`/delete?name=${name}`);
	remove_from_history(name);
    } else if(button_name == "turn on") {
	let name = node_name;
	request_action(`/turn_on?name=${name}`);
    } else if(button_name == "turn off") {
	let name = node_name;
	request_action(`/turn_off?name=${name}`);
    }
}

function create_node(data, buttons) {
    let name = data.name ? data.name : "house";
    let status = data.status ? data.status : "";
    let usage_string = data.current_usage.toString()
	+ (data.max_power ? "A / " + data.max_power.toString() : "A");

    let li = document.createElement('li');
    let label_span = document.createElement('span');
    label_span.style.color = name_to_color(name);
    label_span.textContent = name + ": " + usage_string;
    label_span.setAttribute('class', 'label ' + status);
    let buttons_span = document.createElement('span');
    buttons_span.setAttribute('class', 'buttons');
    for(const button_name of buttons) {
	let link_elt = document.createElement('a');
	link_elt.textContent = button_name;
	link_elt.setAttribute('onclick', 'handle_click(\'' +
			      name + '\', \'' + button_name + '\')');
	buttons_span.appendChild(link_elt);
    }
    li.appendChild(label_span);
    li.appendChild(buttons_span);
    return li;
}

function populate_tree(root, data) {

    if(data.type == "house" || data.type == "breaker") {
	let child = create_node(data, ["new appliance", "new breaker", "delete"]);
	let ul = document.createElement('ul');
	child.appendChild(ul);

	root.appendChild(child);

	for(const child of data.children) {
	    populate_tree(ul, child);
	}
    } else if(data.type == "appliance") {
	let child = create_node(data, ["turn on", "turn off", "delete"]);

	root.appendChild(child);
    }
}

function request_info(cb) {
    let xmlHttp = new XMLHttpRequest();
    xmlHttp.onload = function() {
	cb(JSON.parse(xmlHttp.responseText));
    }
    xmlHttp.open("GET", "/info", true);
    xmlHttp.send(null);
}
</script>
